var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/index.common.js
import { connect as schedulerUtilsConnect } from "@permaweb/ao-scheduler-utils";

// node_modules/hyper-async/dist/index.js
var Async = (fork) => ({
  fork,
  toPromise: () => new Promise((resolve, reject3) => fork(reject3, resolve)),
  map: (fn) => Async((rej, res) => fork(rej, (x) => res(fn(x)))),
  bimap: (f, g) => Async(
    (rej, res) => fork(
      (x) => rej(f(x)),
      (x) => res(g(x))
    )
  ),
  chain: (fn) => Async((rej, res) => fork(rej, (x) => fn(x).fork(rej, res))),
  bichain: (f, g) => Async(
    (rej, res) => fork(
      (x) => f(x).fork(rej, res),
      (x) => g(x).fork(rej, res)
    )
  ),
  fold: (f, g) => Async(
    (rej, res) => fork(
      (x) => f(x).fork(rej, res),
      (x) => g(x).fork(rej, res)
    )
  )
});
var of = (x) => Async((rej, res) => res(x));
var Resolved = (x) => Async((rej, res) => res(x));
var Rejected = (x) => Async((rej, res) => rej(x));
var fromPromise = (f) => (...args) => Async(
  (rej, res) => f(...args).then(res).catch(rej)
);

// src/client/ao-mu.js
function deployMessageWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployMessage");
  return (args) => {
    return of(args).chain(
      fromPromise(({ processId, data, tags, anchor, signer }) => (
        /**
         * The processId is the target set on the data item
         * See https://specs.g8way.io/?tx=xwOgX-MmqN5_-Ny_zNu2A8o-PnTGsoRb_3FrtiMAkuw
         */
        signer({ data, tags, target: processId, anchor })
      ))
    ).chain(
      (signedDataItem) => of(signedDataItem).chain(fromPromise(
        async (signedDataItem2) => fetch2(
          MU_URL2,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/octet-stream",
              Accept: "application/json"
            },
            body: signedDataItem2.raw
          }
        )
      )).bichain(
        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),
        fromPromise(
          async (res) => {
            if (res.ok)
              return res.json();
            throw new Error(`${res.status}: ${await res.text()}`);
          }
        )
      ).bimap(
        logger.tap("Error encountered when writing message via MU"),
        logger.tap("Successfully wrote message via MU")
      ).map((res) => ({ res, messageId: signedDataItem.id }))
    ).toPromise();
  };
}
function deployProcessWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployProcess");
  return (args) => {
    return of(args).chain(fromPromise(({ data, tags, signer }) => signer({ data, tags }))).chain(
      (signedDataItem) => of(signedDataItem).chain(fromPromise(
        async (signedDataItem2) => fetch2(
          MU_URL2,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/octet-stream",
              Accept: "application/json"
            },
            body: signedDataItem2.raw
          }
        )
      )).bichain(
        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),
        fromPromise(
          async (res) => {
            if (res.ok)
              return res.json();
            throw new Error(`${res.status}: ${await res.text()}`);
          }
        )
      ).bimap(
        logger.tap("Error encountered when deploying process via MU"),
        logger.tap("Successfully deployed process via MU")
      ).map((res) => ({ res, processId: signedDataItem.id }))
    ).toPromise();
  };
}

// src/client/ao-cu.js
function loadResultWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {
  return ({ id, processId }) => {
    return of(`${CU_URL2}/result/${id}?process-id=${processId}`).map(logger.tap("fetching message result from CU")).chain(fromPromise(
      async (url) => fetch2(url, {
        method: "GET",
        headers: {
          Accept: "application/json"
        }
      }).then((res) => res.json())
    )).toPromise();
  };
}

// src/client/ao-su.js
var loadProcessMetaWith = ({ fetch: fetch2 }) => {
  return async ({ suUrl, processId }) => {
    return fetch2(`${suUrl}/processes/${processId}`, { method: "GET" }).then((res) => res.json());
  };
};

// src/client/gateway.js
import { path } from "ramda";
import { z } from "zod";
function loadTransactionMetaWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 }) {
  const GET_TRANSACTIONS_QUERY = `
    query GetTransactions ($transactionIds: [ID!]!) {
      transactions(ids: $transactionIds) {
        edges {
          node {
            owner {
              address
            }
            tags {
              name
              value
            }
            block {
              id
              height
              timestamp
            }
          }
        }
      }
    }`;
  const transactionConnectionSchema = z.object({
    data: z.object({
      transactions: z.object({
        edges: z.array(z.object({
          node: z.record(z.any())
        }))
      })
    })
  });
  return (id) => of(id).chain(fromPromise(
    (id2) => fetch2(`${GATEWAY_URL2}/graphql`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: GET_TRANSACTIONS_QUERY,
        variables: { transactionIds: [id2] }
      })
    }).then((res) => res.json()).then(transactionConnectionSchema.parse).then(path(["data", "transactions", "edges", "0", "node"]))
  )).toPromise();
}

// src/logger.js
import debug from "debug";
import { tap } from "ramda";
var createLogger = (name = "@permaweb/ao-connect") => {
  const logger = debug(name);
  logger.child = (name2) => createLogger(`${logger.namespace}:${name2}`);
  logger.tap = (note, ...rest) => tap((...args) => logger(note, ...rest, ...args));
  return logger;
};

// src/lib/result/index.js
import { identity } from "ramda";

// src/lib/utils.js
import {
  F,
  T,
  __,
  append,
  assoc,
  chain,
  concat,
  cond,
  defaultTo,
  equals,
  has,
  includes,
  is,
  join,
  map,
  pipe,
  propOr,
  reduce
} from "ramda";
import { ZodError, ZodIssueCode } from "zod";
function parseTags(rawTags) {
  return pipe(
    defaultTo([]),
    reduce(
      (map2, tag) => pipe(
        // [value, value, ...] || []
        propOr([], tag.name),
        // [value]
        append(tag.value),
        // { [name]: [value, value, ...] }
        assoc(tag.name, __, map2)
      )(map2),
      {}
    ),
    /**
    * If the field is only a singly list, then extract the one value.
    *
    * Otherwise, keep the value as a list.
    */
    map((values) => values.length > 1 ? values : values[0])
  )(rawTags);
}
function eqOrIncludes(val) {
  return cond([
    [is(String), equals(val)],
    [is(Array), includes(val)],
    [T, F]
  ]);
}
function trimSlash(str = "") {
  if (!str.endsWith("/"))
    return str;
  return trimSlash(str.slice(0, -1));
}
function errFrom(err) {
  let e;
  if (is(ZodError, err)) {
    e = new Error(mapZodErr(err));
    e.stack += err.stack;
  } else if (is(Error, err)) {
    e = err;
  } else if (has("message", err)) {
    e = new Error(err.message);
  } else if (is(String, err)) {
    e = new Error(err);
  } else {
    e = new Error("An error occurred");
  }
  return e;
}
function mapZodErr(zodErr) {
  return pipe(
    (zodErr2) => (
      /**
       * Take a ZodError and flatten it's issues into a single depth array
       */
      function gatherZodIssues(zodErr3, status, contextCode) {
        return reduce(
          (issues, issue) => pipe(
            cond([
              /**
               * These issue codes indicate nested ZodErrors, so we resursively gather those
               * See https://github.com/colinhacks/zod/blob/HEAD/ERROR_HANDLING.md#zodissuecode
               */
              [
                equals(ZodIssueCode.invalid_arguments),
                () => gatherZodIssues(issue.argumentsError, 422, "Invalid Arguments")
              ],
              [
                equals(ZodIssueCode.invalid_return_type),
                () => gatherZodIssues(issue.returnTypeError, 500, "Invalid Return")
              ],
              [
                equals(ZodIssueCode.invalid_union),
                // An array of ZodErrors, so map over and flatten them all
                () => chain((i) => gatherZodIssues(i, 400, "Invalid Union"), issue.unionErrors)
              ],
              [T, () => [{ ...issue, status, contextCode }]]
            ]),
            concat(issues)
          )(issue.code),
          [],
          zodErr3.issues
        );
      }(zodErr2, 400, "")
    ),
    /**
     * combine all zod issues into a list of { message, status }
     * summaries of each issue
     */
    (zodIssues) => reduce(
      (acc, zodIssue) => {
        const { message: message2, path: _path, contextCode: _contextCode } = zodIssue;
        const path2 = _path[1] || _path[0];
        const contextCode = _contextCode ? `${_contextCode} ` : "";
        acc.push(`${contextCode}'${path2}': ${message2}.`);
        return acc;
      },
      [],
      zodIssues
    ),
    join(" | ")
  )(zodErr);
}

// src/lib/result/verify-input.js
import { z as z2 } from "zod";
var inputSchema = z2.object({
  id: z2.string().min(1, { message: "message is required to be a message id" }),
  processId: z2.string().min(1, { message: "process is required to be a process id" })
});
function verifyInputWith() {
  return (ctx) => {
    return of(ctx).map(inputSchema.parse).map(() => ctx);
  };
}

// src/dal.js
import { z as z3 } from "zod";
var tagSchema = z3.object({
  name: z3.string(),
  value: z3.string()
});
var loadResultSchema = z3.function().args(z3.object({
  id: z3.string().min(1, { message: "message id is required" }),
  processId: z3.string().min(1, { message: "process id is required" })
})).returns(z3.promise(z3.any()));
var deployMessageSchema = z3.function().args(z3.object({
  processId: z3.string(),
  data: z3.any(),
  tags: z3.array(tagSchema),
  anchor: z3.string().optional(),
  signer: z3.any()
})).returns(z3.promise(
  z3.object({
    messageId: z3.string()
  }).passthrough()
));
var deployProcessSchema = z3.function().args(z3.object({
  data: z3.any(),
  tags: z3.array(tagSchema),
  signer: z3.any()
})).returns(z3.promise(
  z3.object({
    processId: z3.string()
  }).passthrough()
));
var loadProcessMetaSchema = z3.function().args(z3.object({
  suUrl: z3.string().url(),
  processId: z3.string()
})).returns(z3.promise(
  z3.object({
    tags: z3.array(tagSchema)
  }).passthrough()
));
var locateSchedulerSchema = z3.function().args(z3.string()).returns(z3.promise(
  z3.object({
    url: z3.string()
  })
));
var validateSchedulerSchema = z3.function().args(z3.string()).returns(z3.promise(z3.boolean()));
var loadTransactionMetaSchema = z3.function().args(z3.string()).returns(z3.promise(
  z3.object({
    tags: z3.array(tagSchema)
  }).passthrough()
));
var signerSchema = z3.function().args(z3.object({
  data: z3.any(),
  tags: z3.array(tagSchema),
  /**
   * target must be set with writeMessage,
   * but not for createProcess
   */
  target: z3.string().optional(),
  anchor: z3.string().optional()
})).returns(z3.promise(
  z3.object({
    id: z3.string(),
    raw: z3.any()
  })
));

// src/lib/result/read.js
function readWith({ loadResult }) {
  loadResult = fromPromise(loadResultSchema.implement(loadResult));
  return (ctx) => {
    return of({ id: ctx.id, processId: ctx.processId }).chain(loadResult);
  };
}

// src/lib/result/index.js
function resultWith(env) {
  const verifyInput = verifyInputWith(env);
  const read = readWith(env);
  return ({ message: message2, process: process2 }) => {
    return of({ id: message2, processId: process2 }).chain(verifyInput).chain(read).map(
      env.logger.tap(
        'readResult result for message "%s": %O',
        message2
      )
    ).map((result2) => result2).bimap(errFrom, identity).toPromise();
  };
}

// src/lib/message/index.js
import { identity as identity2 } from "ramda";

// src/lib/message/verify-process.js
import { isNotNil, prop } from "ramda";
function verifyProcessTagsWith({ loadProcessMeta, locateScheduler, logger }) {
  const checkTag2 = (name, pred, err) => (tags) => pred(tags[name]) ? Resolved(tags) : Rejected(`Tag '${name}': ${err}`);
  loadProcessMeta = fromPromise(loadProcessMetaSchema.implement(loadProcessMeta));
  locateScheduler = fromPromise(locateSchedulerSchema.implement(locateScheduler));
  return (id) => {
    return of(id).map(logger.tap("Verifying Process")).map(logger.tap("Locating Scheduler for Process to retrieve Process meta")).chain(locateScheduler).chain(({ url }) => loadProcessMeta({ suUrl: trimSlash(url), processId: id })).map(prop("tags")).map(parseTags).chain(checkTag2("Data-Protocol", eqOrIncludes("ao"), "value 'ao' was not found on process")).chain(checkTag2("Type", eqOrIncludes("Process"), "value 'Process' was not found on process")).chain(checkTag2("Module", isNotNil, "was not found on process"));
  };
}
function verifyProcessWith(env) {
  const verifyProcess = verifyProcessTagsWith(env);
  return (ctx) => {
    return of(ctx.id).chain(verifyProcess).map(() => ctx);
  };
}

// src/lib/message/upload-message.js
import { z as z4 } from "zod";
import { __ as __2, always, append as append2, assoc as assoc2, concat as concat2, defaultTo as defaultTo2, ifElse, pipe as pipe2, prop as prop2, propEq, reject } from "ramda";
var tagSchema2 = z4.array(z4.object({
  name: z4.string(),
  value: z4.string()
}));
function buildTagsWith() {
  return (ctx) => {
    return of(ctx.tags).map(defaultTo2([])).map(concat2(__2, [
      { name: "Data-Protocol", value: "ao" },
      { name: "Variant", value: "ao.TN.1" },
      { name: "Type", value: "Message" },
      { name: "SDK", value: "ao" }
    ])).map(tagSchema2.parse).map(assoc2("tags", __2, ctx));
  };
}
function buildDataWith({ logger }) {
  function removeTagsByName(name) {
    return (tags) => reject(propEq(name, "name"), tags);
  }
  return (ctx) => {
    return of(ctx).chain(ifElse(
      always(ctx.data),
      /**
       * data is provided as input, so do nothing
       */
      () => Resolved(ctx),
      /**
       * Just generate a random value for data
       */
      () => Resolved(Math.random().toString().slice(-4)).map(assoc2("data", __2, ctx)).map(
        (ctx2) => pipe2(
          prop2("tags"),
          removeTagsByName("Content-Type"),
          append2({ name: "Content-Type", value: "text/plain" }),
          assoc2("tags", __2, ctx2)
        )(ctx2)
      ).map(logger.tap('added pseudo-random string as message "data"'))
    ));
  };
}
function uploadMessageWith(env) {
  const buildTags = buildTagsWith(env);
  const buildData = buildDataWith(env);
  const deployMessage = deployMessageSchema.implement(env.deployMessage);
  return (ctx) => {
    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(
      ({ id, data, tags, anchor, signer }) => deployMessage({ processId: id, data, tags, anchor, signer: signerSchema.implement(signer) })
    )).map((res) => assoc2("messageId", res.messageId, ctx));
  };
}

// src/lib/message/index.js
function messageWith(env) {
  const verifyProcess = verifyProcessWith(env);
  const uploadMessage = uploadMessageWith(env);
  return ({ process: process2, data, tags, anchor, signer }) => {
    return of({ id: process2, data, tags, anchor, signer }).chain(verifyProcess).chain(uploadMessage).map((ctx) => ctx.messageId).bimap(errFrom, identity2).toPromise();
  };
}

// src/lib/spawn/index.js
import { identity as identity3 } from "ramda";

// src/lib/spawn/verify-inputs.js
import { isNotNil as isNotNil2, prop as prop3 } from "ramda";
var checkTag = (name, pred, err) => (tags) => pred(tags[name]) ? Resolved(tags) : Rejected(`Tag '${name}': ${err}`);
function verifyModuleWith({ loadTransactionMeta, logger }) {
  loadTransactionMeta = fromPromise(loadTransactionMetaSchema.implement(loadTransactionMeta));
  return (module) => of(module).chain(loadTransactionMeta).map(prop3("tags")).map(parseTags).chain(checkTag("Data-Protocol", eqOrIncludes("ao"), "value 'ao' was not found on module")).chain(checkTag("Type", eqOrIncludes("Module"), "value 'Module' was not found on module")).chain(checkTag("Module-Format", isNotNil2, "was not found on module")).chain(checkTag("Input-Encoding", isNotNil2, "was not found on module")).chain(checkTag("Output-Encoding", isNotNil2, "was not found on module")).bimap(
    logger.tap("Verifying module source failed: %s"),
    logger.tap("Verified module source")
  );
}
function verifySchedulerWith({ logger, validateScheduler }) {
  validateScheduler = fromPromise(validateSchedulerSchema.implement(validateScheduler));
  return (scheduler) => of(scheduler).chain(
    (scheduler2) => validateScheduler(scheduler2).chain((isValid) => isValid ? Resolved(scheduler2) : Rejected(`Valid Scheduler-Location owned by ${scheduler2} not found`))
  ).bimap(
    logger.tap("Verifying scheduler failed: %s"),
    logger.tap("Verified scheduler")
  );
}
function verifySignerWith({ logger }) {
  return (signer) => of(signer).map(logger.tap("Checking for signer")).chain((signer2) => signer2 ? Resolved(signer2) : Rejected("signer not found"));
}
function verifyInputsWith(env) {
  const logger = env.logger.child("verifyInput");
  env = { ...env, logger };
  const verifyModule = verifyModuleWith(env);
  const verifyScheduler = verifySchedulerWith(env);
  const verifySigner = verifySignerWith(env);
  return (ctx) => {
    return of(ctx).chain((ctx2) => verifyModule(ctx2.module).map(() => ctx2)).chain((ctx2) => verifyScheduler(ctx2.scheduler)).map(() => ctx).chain((ctx2) => verifySigner(ctx2.signer).map(() => ctx2)).bimap(
      logger.tap("Error when verify input: %s"),
      logger.tap("Successfully verified inputs")
    );
  };
}

// src/lib/spawn/upload-process.js
import { z as z5 } from "zod";
import { __ as __3, always as always2, append as append3, assoc as assoc3, concat as concat3, defaultTo as defaultTo3, ifElse as ifElse2, pipe as pipe3, prop as prop4, propEq as propEq2, reject as reject2 } from "ramda";
var tagSchema3 = z5.array(z5.object({
  name: z5.string(),
  value: z5.string()
}));
function buildTagsWith2() {
  return (ctx) => {
    return of(ctx).map(prop4("tags")).map(defaultTo3([])).map(concat3(__3, [
      { name: "Data-Protocol", value: "ao" },
      { name: "Variant", value: "ao.TN.1" },
      { name: "Type", value: "Process" },
      { name: "Module", value: ctx.module },
      { name: "Scheduler", value: ctx.scheduler },
      { name: "SDK", value: "ao" }
    ])).map(tagSchema3.parse).map(assoc3("tags", __3, ctx));
  };
}
function buildDataWith2({ logger }) {
  function removeTagsByName(name) {
    return (tags) => reject2(propEq2(name, "name"), tags);
  }
  return (ctx) => {
    return of(ctx).chain(ifElse2(
      always2(ctx.data),
      /**
       * data is provided as input, so do nothing
       */
      () => Resolved(ctx),
      /**
       * Just generate a random value for data
       */
      () => Resolved(Math.random().toString().slice(-4)).map(assoc3("data", __3, ctx)).map(
        (ctx2) => pipe3(
          prop4("tags"),
          removeTagsByName("Content-Type"),
          append3({ name: "Content-Type", value: "text/plain" }),
          assoc3("tags", __3, ctx2)
        )(ctx2)
      ).map(logger.tap('added pseudo-random string as process "data"'))
    ));
  };
}
function uploadProcessWith(env) {
  const logger = env.logger.child("uploadProcess");
  env = { ...env, logger };
  const buildTags = buildTagsWith2(env);
  const buildData = buildDataWith2(env);
  const deployProcess = deployProcessSchema.implement(env.deployProcess);
  return (ctx) => {
    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(
      ({ data, tags, signer }) => deployProcess({ data, tags, signer: signerSchema.implement(signer) })
    )).map((res) => assoc3("processId", res.processId, ctx));
  };
}

// src/lib/spawn/index.js
function spawnWith(env) {
  const verifyInputs = verifyInputsWith(env);
  const uploadProcess = uploadProcessWith(env);
  return ({ module, scheduler, signer, tags, data }) => {
    return of({ module, scheduler, signer, tags, data }).chain(verifyInputs).chain(uploadProcess).map((ctx) => ctx.processId).bimap(errFrom, identity3).toPromise();
  };
}

// src/index.common.js
var DEFAULT_GATEWAY_URL = "https://arweave.net";
var DEFAULT_MU_URL = "https://ao-mu-1.onrender.com";
var DEFAULT_CU_URL = "https://ao-cu-1.onrender.com";
function connect({
  GATEWAY_URL: GATEWAY_URL2 = DEFAULT_GATEWAY_URL,
  MU_URL: MU_URL2 = DEFAULT_MU_URL,
  CU_URL: CU_URL2 = DEFAULT_CU_URL
} = {}) {
  const logger = createLogger("@permaweb/ao-sdk");
  const { locate, validate } = schedulerUtilsConnect({ cacheSize: 100, GATEWAY_URL: GATEWAY_URL2 });
  const resultLogger = logger.child("result");
  const result2 = resultWith({
    loadResult: loadResultWith({ fetch, CU_URL: CU_URL2, logger: resultLogger }),
    logger: resultLogger
  });
  const messageLogger = logger.child("message");
  const message2 = messageWith({
    loadProcessMeta: loadProcessMetaWith({ fetch }),
    locateScheduler: locate,
    deployMessage: deployMessageWith({ fetch, MU_URL: MU_URL2, logger: messageLogger }),
    logger: messageLogger
  });
  const spawnLogger = logger.child("spawn");
  const spawn2 = spawnWith({
    loadTransactionMeta: loadTransactionMetaWith({ fetch, GATEWAY_URL: GATEWAY_URL2 }),
    validateScheduler: validate,
    deployProcess: deployProcessWith({ fetch, MU_URL: MU_URL2, logger: spawnLogger }),
    logger: spawnLogger
  });
  return { result: result2, message: message2, spawn: spawn2 };
}

// src/client/node/wallet.js
var wallet_exports = {};
__export(wallet_exports, {
  createDataItemSigner: () => createDataItemSigner
});
import WarpArBundles from "warp-arbundles";
var { createData, ArweaveSigner } = WarpArBundles;
function createDataItemSigner(wallet) {
  const signer = async ({ data, tags, target, anchor }) => {
    const signer2 = new ArweaveSigner(wallet);
    const dataItem = createData(data, signer2, { tags, target, anchor });
    return dataItem.sign(signer2).then(async () => ({
      id: await dataItem.id,
      raw: await dataItem.getRaw()
    }));
  };
  return signer;
}

// src/index.js
var GATEWAY_URL = process.env.GATEWAY_URL || void 0;
var MU_URL = process.env.MU_URL || void 0;
var CU_URL = process.env.CU_URL || void 0;
var { result, message, spawn } = connect({ GATEWAY_URL, MU_URL, CU_URL });
var createDataItemSigner2 = wallet_exports.createDataItemSigner;
export {
  connect,
  createDataItemSigner2 as createDataItemSigner,
  message,
  result,
  spawn
};
