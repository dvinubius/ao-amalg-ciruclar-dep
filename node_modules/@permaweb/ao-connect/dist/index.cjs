var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var src_exports = {};
__export(src_exports, {
  connect: () => connect,
  createDataItemSigner: () => createDataItemSigner2,
  message: () => message,
  result: () => result,
  spawn: () => spawn
});
module.exports = __toCommonJS(src_exports);

// src/index.common.js
var import_ao_scheduler_utils = require("@permaweb/ao-scheduler-utils");

// node_modules/hyper-async/dist/index.js
var Async = (fork) => ({
  fork,
  toPromise: () => new Promise((resolve, reject3) => fork(reject3, resolve)),
  map: (fn) => Async((rej, res) => fork(rej, (x) => res(fn(x)))),
  bimap: (f, g) => Async(
    (rej, res) => fork(
      (x) => rej(f(x)),
      (x) => res(g(x))
    )
  ),
  chain: (fn) => Async((rej, res) => fork(rej, (x) => fn(x).fork(rej, res))),
  bichain: (f, g) => Async(
    (rej, res) => fork(
      (x) => f(x).fork(rej, res),
      (x) => g(x).fork(rej, res)
    )
  ),
  fold: (f, g) => Async(
    (rej, res) => fork(
      (x) => f(x).fork(rej, res),
      (x) => g(x).fork(rej, res)
    )
  )
});
var of = (x) => Async((rej, res) => res(x));
var Resolved = (x) => Async((rej, res) => res(x));
var Rejected = (x) => Async((rej, res) => rej(x));
var fromPromise = (f) => (...args) => Async(
  (rej, res) => f(...args).then(res).catch(rej)
);

// src/client/ao-mu.js
function deployMessageWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployMessage");
  return (args) => {
    return of(args).chain(
      fromPromise(({ processId, data, tags, anchor, signer }) => (
        /**
         * The processId is the target set on the data item
         * See https://specs.g8way.io/?tx=xwOgX-MmqN5_-Ny_zNu2A8o-PnTGsoRb_3FrtiMAkuw
         */
        signer({ data, tags, target: processId, anchor })
      ))
    ).chain(
      (signedDataItem) => of(signedDataItem).chain(fromPromise(
        async (signedDataItem2) => fetch2(
          MU_URL2,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/octet-stream",
              Accept: "application/json"
            },
            body: signedDataItem2.raw
          }
        )
      )).bichain(
        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),
        fromPromise(
          async (res) => {
            if (res.ok)
              return res.json();
            throw new Error(`${res.status}: ${await res.text()}`);
          }
        )
      ).bimap(
        logger.tap("Error encountered when writing message via MU"),
        logger.tap("Successfully wrote message via MU")
      ).map((res) => ({ res, messageId: signedDataItem.id }))
    ).toPromise();
  };
}
function deployProcessWith({ fetch: fetch2, MU_URL: MU_URL2, logger: _logger }) {
  const logger = _logger.child("deployProcess");
  return (args) => {
    return of(args).chain(fromPromise(({ data, tags, signer }) => signer({ data, tags }))).chain(
      (signedDataItem) => of(signedDataItem).chain(fromPromise(
        async (signedDataItem2) => fetch2(
          MU_URL2,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/octet-stream",
              Accept: "application/json"
            },
            body: signedDataItem2.raw
          }
        )
      )).bichain(
        (err) => Rejected(new Error(`Error while communicating with MU: ${JSON.stringify(err)}`)),
        fromPromise(
          async (res) => {
            if (res.ok)
              return res.json();
            throw new Error(`${res.status}: ${await res.text()}`);
          }
        )
      ).bimap(
        logger.tap("Error encountered when deploying process via MU"),
        logger.tap("Successfully deployed process via MU")
      ).map((res) => ({ res, processId: signedDataItem.id }))
    ).toPromise();
  };
}

// src/client/ao-cu.js
function loadResultWith({ fetch: fetch2, CU_URL: CU_URL2, logger }) {
  return ({ id, processId }) => {
    return of(`${CU_URL2}/result/${id}?process-id=${processId}`).map(logger.tap("fetching message result from CU")).chain(fromPromise(
      async (url) => fetch2(url, {
        method: "GET",
        headers: {
          Accept: "application/json"
        }
      }).then((res) => res.json())
    )).toPromise();
  };
}

// src/client/ao-su.js
var loadProcessMetaWith = ({ fetch: fetch2 }) => {
  return async ({ suUrl, processId }) => {
    return fetch2(`${suUrl}/processes/${processId}`, { method: "GET" }).then((res) => res.json());
  };
};

// src/client/gateway.js
var import_ramda = require("ramda");
var import_zod = require("zod");
function loadTransactionMetaWith({ fetch: fetch2, GATEWAY_URL: GATEWAY_URL2 }) {
  const GET_TRANSACTIONS_QUERY = `
    query GetTransactions ($transactionIds: [ID!]!) {
      transactions(ids: $transactionIds) {
        edges {
          node {
            owner {
              address
            }
            tags {
              name
              value
            }
            block {
              id
              height
              timestamp
            }
          }
        }
      }
    }`;
  const transactionConnectionSchema = import_zod.z.object({
    data: import_zod.z.object({
      transactions: import_zod.z.object({
        edges: import_zod.z.array(import_zod.z.object({
          node: import_zod.z.record(import_zod.z.any())
        }))
      })
    })
  });
  return (id) => of(id).chain(fromPromise(
    (id2) => fetch2(`${GATEWAY_URL2}/graphql`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        query: GET_TRANSACTIONS_QUERY,
        variables: { transactionIds: [id2] }
      })
    }).then((res) => res.json()).then(transactionConnectionSchema.parse).then((0, import_ramda.path)(["data", "transactions", "edges", "0", "node"]))
  )).toPromise();
}

// src/logger.js
var import_debug = __toESM(require("debug"), 1);
var import_ramda2 = require("ramda");
var createLogger = (name = "@permaweb/ao-connect") => {
  const logger = (0, import_debug.default)(name);
  logger.child = (name2) => createLogger(`${logger.namespace}:${name2}`);
  logger.tap = (note, ...rest) => (0, import_ramda2.tap)((...args) => logger(note, ...rest, ...args));
  return logger;
};

// src/lib/result/index.js
var import_ramda4 = require("ramda");

// src/lib/utils.js
var import_ramda3 = require("ramda");
var import_zod2 = require("zod");
function parseTags(rawTags) {
  return (0, import_ramda3.pipe)(
    (0, import_ramda3.defaultTo)([]),
    (0, import_ramda3.reduce)(
      (map2, tag) => (0, import_ramda3.pipe)(
        // [value, value, ...] || []
        (0, import_ramda3.propOr)([], tag.name),
        // [value]
        (0, import_ramda3.append)(tag.value),
        // { [name]: [value, value, ...] }
        (0, import_ramda3.assoc)(tag.name, import_ramda3.__, map2)
      )(map2),
      {}
    ),
    /**
    * If the field is only a singly list, then extract the one value.
    *
    * Otherwise, keep the value as a list.
    */
    (0, import_ramda3.map)((values) => values.length > 1 ? values : values[0])
  )(rawTags);
}
function eqOrIncludes(val) {
  return (0, import_ramda3.cond)([
    [(0, import_ramda3.is)(String), (0, import_ramda3.equals)(val)],
    [(0, import_ramda3.is)(Array), (0, import_ramda3.includes)(val)],
    [import_ramda3.T, import_ramda3.F]
  ]);
}
function trimSlash(str = "") {
  if (!str.endsWith("/"))
    return str;
  return trimSlash(str.slice(0, -1));
}
function errFrom(err) {
  let e;
  if ((0, import_ramda3.is)(import_zod2.ZodError, err)) {
    e = new Error(mapZodErr(err));
    e.stack += err.stack;
  } else if ((0, import_ramda3.is)(Error, err)) {
    e = err;
  } else if ((0, import_ramda3.has)("message", err)) {
    e = new Error(err.message);
  } else if ((0, import_ramda3.is)(String, err)) {
    e = new Error(err);
  } else {
    e = new Error("An error occurred");
  }
  return e;
}
function mapZodErr(zodErr) {
  return (0, import_ramda3.pipe)(
    (zodErr2) => (
      /**
       * Take a ZodError and flatten it's issues into a single depth array
       */
      function gatherZodIssues(zodErr3, status, contextCode) {
        return (0, import_ramda3.reduce)(
          (issues, issue) => (0, import_ramda3.pipe)(
            (0, import_ramda3.cond)([
              /**
               * These issue codes indicate nested ZodErrors, so we resursively gather those
               * See https://github.com/colinhacks/zod/blob/HEAD/ERROR_HANDLING.md#zodissuecode
               */
              [
                (0, import_ramda3.equals)(import_zod2.ZodIssueCode.invalid_arguments),
                () => gatherZodIssues(issue.argumentsError, 422, "Invalid Arguments")
              ],
              [
                (0, import_ramda3.equals)(import_zod2.ZodIssueCode.invalid_return_type),
                () => gatherZodIssues(issue.returnTypeError, 500, "Invalid Return")
              ],
              [
                (0, import_ramda3.equals)(import_zod2.ZodIssueCode.invalid_union),
                // An array of ZodErrors, so map over and flatten them all
                () => (0, import_ramda3.chain)((i) => gatherZodIssues(i, 400, "Invalid Union"), issue.unionErrors)
              ],
              [import_ramda3.T, () => [{ ...issue, status, contextCode }]]
            ]),
            (0, import_ramda3.concat)(issues)
          )(issue.code),
          [],
          zodErr3.issues
        );
      }(zodErr2, 400, "")
    ),
    /**
     * combine all zod issues into a list of { message, status }
     * summaries of each issue
     */
    (zodIssues) => (0, import_ramda3.reduce)(
      (acc, zodIssue) => {
        const { message: message2, path: _path, contextCode: _contextCode } = zodIssue;
        const path2 = _path[1] || _path[0];
        const contextCode = _contextCode ? `${_contextCode} ` : "";
        acc.push(`${contextCode}'${path2}': ${message2}.`);
        return acc;
      },
      [],
      zodIssues
    ),
    (0, import_ramda3.join)(" | ")
  )(zodErr);
}

// src/lib/result/verify-input.js
var import_zod3 = require("zod");
var inputSchema = import_zod3.z.object({
  id: import_zod3.z.string().min(1, { message: "message is required to be a message id" }),
  processId: import_zod3.z.string().min(1, { message: "process is required to be a process id" })
});
function verifyInputWith() {
  return (ctx) => {
    return of(ctx).map(inputSchema.parse).map(() => ctx);
  };
}

// src/dal.js
var import_zod4 = require("zod");
var tagSchema = import_zod4.z.object({
  name: import_zod4.z.string(),
  value: import_zod4.z.string()
});
var loadResultSchema = import_zod4.z.function().args(import_zod4.z.object({
  id: import_zod4.z.string().min(1, { message: "message id is required" }),
  processId: import_zod4.z.string().min(1, { message: "process id is required" })
})).returns(import_zod4.z.promise(import_zod4.z.any()));
var deployMessageSchema = import_zod4.z.function().args(import_zod4.z.object({
  processId: import_zod4.z.string(),
  data: import_zod4.z.any(),
  tags: import_zod4.z.array(tagSchema),
  anchor: import_zod4.z.string().optional(),
  signer: import_zod4.z.any()
})).returns(import_zod4.z.promise(
  import_zod4.z.object({
    messageId: import_zod4.z.string()
  }).passthrough()
));
var deployProcessSchema = import_zod4.z.function().args(import_zod4.z.object({
  data: import_zod4.z.any(),
  tags: import_zod4.z.array(tagSchema),
  signer: import_zod4.z.any()
})).returns(import_zod4.z.promise(
  import_zod4.z.object({
    processId: import_zod4.z.string()
  }).passthrough()
));
var loadProcessMetaSchema = import_zod4.z.function().args(import_zod4.z.object({
  suUrl: import_zod4.z.string().url(),
  processId: import_zod4.z.string()
})).returns(import_zod4.z.promise(
  import_zod4.z.object({
    tags: import_zod4.z.array(tagSchema)
  }).passthrough()
));
var locateSchedulerSchema = import_zod4.z.function().args(import_zod4.z.string()).returns(import_zod4.z.promise(
  import_zod4.z.object({
    url: import_zod4.z.string()
  })
));
var validateSchedulerSchema = import_zod4.z.function().args(import_zod4.z.string()).returns(import_zod4.z.promise(import_zod4.z.boolean()));
var loadTransactionMetaSchema = import_zod4.z.function().args(import_zod4.z.string()).returns(import_zod4.z.promise(
  import_zod4.z.object({
    tags: import_zod4.z.array(tagSchema)
  }).passthrough()
));
var signerSchema = import_zod4.z.function().args(import_zod4.z.object({
  data: import_zod4.z.any(),
  tags: import_zod4.z.array(tagSchema),
  /**
   * target must be set with writeMessage,
   * but not for createProcess
   */
  target: import_zod4.z.string().optional(),
  anchor: import_zod4.z.string().optional()
})).returns(import_zod4.z.promise(
  import_zod4.z.object({
    id: import_zod4.z.string(),
    raw: import_zod4.z.any()
  })
));

// src/lib/result/read.js
function readWith({ loadResult }) {
  loadResult = fromPromise(loadResultSchema.implement(loadResult));
  return (ctx) => {
    return of({ id: ctx.id, processId: ctx.processId }).chain(loadResult);
  };
}

// src/lib/result/index.js
function resultWith(env) {
  const verifyInput = verifyInputWith(env);
  const read = readWith(env);
  return ({ message: message2, process: process2 }) => {
    return of({ id: message2, processId: process2 }).chain(verifyInput).chain(read).map(
      env.logger.tap(
        'readResult result for message "%s": %O',
        message2
      )
    ).map((result2) => result2).bimap(errFrom, import_ramda4.identity).toPromise();
  };
}

// src/lib/message/index.js
var import_ramda7 = require("ramda");

// src/lib/message/verify-process.js
var import_ramda5 = require("ramda");
function verifyProcessTagsWith({ loadProcessMeta, locateScheduler, logger }) {
  const checkTag2 = (name, pred, err) => (tags) => pred(tags[name]) ? Resolved(tags) : Rejected(`Tag '${name}': ${err}`);
  loadProcessMeta = fromPromise(loadProcessMetaSchema.implement(loadProcessMeta));
  locateScheduler = fromPromise(locateSchedulerSchema.implement(locateScheduler));
  return (id) => {
    return of(id).map(logger.tap("Verifying Process")).map(logger.tap("Locating Scheduler for Process to retrieve Process meta")).chain(locateScheduler).chain(({ url }) => loadProcessMeta({ suUrl: trimSlash(url), processId: id })).map((0, import_ramda5.prop)("tags")).map(parseTags).chain(checkTag2("Data-Protocol", eqOrIncludes("ao"), "value 'ao' was not found on process")).chain(checkTag2("Type", eqOrIncludes("Process"), "value 'Process' was not found on process")).chain(checkTag2("Module", import_ramda5.isNotNil, "was not found on process"));
  };
}
function verifyProcessWith(env) {
  const verifyProcess = verifyProcessTagsWith(env);
  return (ctx) => {
    return of(ctx.id).chain(verifyProcess).map(() => ctx);
  };
}

// src/lib/message/upload-message.js
var import_zod5 = require("zod");
var import_ramda6 = require("ramda");
var tagSchema2 = import_zod5.z.array(import_zod5.z.object({
  name: import_zod5.z.string(),
  value: import_zod5.z.string()
}));
function buildTagsWith() {
  return (ctx) => {
    return of(ctx.tags).map((0, import_ramda6.defaultTo)([])).map((0, import_ramda6.concat)(import_ramda6.__, [
      { name: "Data-Protocol", value: "ao" },
      { name: "Variant", value: "ao.TN.1" },
      { name: "Type", value: "Message" },
      { name: "SDK", value: "ao" }
    ])).map(tagSchema2.parse).map((0, import_ramda6.assoc)("tags", import_ramda6.__, ctx));
  };
}
function buildDataWith({ logger }) {
  function removeTagsByName(name) {
    return (tags) => (0, import_ramda6.reject)((0, import_ramda6.propEq)(name, "name"), tags);
  }
  return (ctx) => {
    return of(ctx).chain((0, import_ramda6.ifElse)(
      (0, import_ramda6.always)(ctx.data),
      /**
       * data is provided as input, so do nothing
       */
      () => Resolved(ctx),
      /**
       * Just generate a random value for data
       */
      () => Resolved(Math.random().toString().slice(-4)).map((0, import_ramda6.assoc)("data", import_ramda6.__, ctx)).map(
        (ctx2) => (0, import_ramda6.pipe)(
          (0, import_ramda6.prop)("tags"),
          removeTagsByName("Content-Type"),
          (0, import_ramda6.append)({ name: "Content-Type", value: "text/plain" }),
          (0, import_ramda6.assoc)("tags", import_ramda6.__, ctx2)
        )(ctx2)
      ).map(logger.tap('added pseudo-random string as message "data"'))
    ));
  };
}
function uploadMessageWith(env) {
  const buildTags = buildTagsWith(env);
  const buildData = buildDataWith(env);
  const deployMessage = deployMessageSchema.implement(env.deployMessage);
  return (ctx) => {
    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(
      ({ id, data, tags, anchor, signer }) => deployMessage({ processId: id, data, tags, anchor, signer: signerSchema.implement(signer) })
    )).map((res) => (0, import_ramda6.assoc)("messageId", res.messageId, ctx));
  };
}

// src/lib/message/index.js
function messageWith(env) {
  const verifyProcess = verifyProcessWith(env);
  const uploadMessage = uploadMessageWith(env);
  return ({ process: process2, data, tags, anchor, signer }) => {
    return of({ id: process2, data, tags, anchor, signer }).chain(verifyProcess).chain(uploadMessage).map((ctx) => ctx.messageId).bimap(errFrom, import_ramda7.identity).toPromise();
  };
}

// src/lib/spawn/index.js
var import_ramda10 = require("ramda");

// src/lib/spawn/verify-inputs.js
var import_ramda8 = require("ramda");
var checkTag = (name, pred, err) => (tags) => pred(tags[name]) ? Resolved(tags) : Rejected(`Tag '${name}': ${err}`);
function verifyModuleWith({ loadTransactionMeta, logger }) {
  loadTransactionMeta = fromPromise(loadTransactionMetaSchema.implement(loadTransactionMeta));
  return (module2) => of(module2).chain(loadTransactionMeta).map((0, import_ramda8.prop)("tags")).map(parseTags).chain(checkTag("Data-Protocol", eqOrIncludes("ao"), "value 'ao' was not found on module")).chain(checkTag("Type", eqOrIncludes("Module"), "value 'Module' was not found on module")).chain(checkTag("Module-Format", import_ramda8.isNotNil, "was not found on module")).chain(checkTag("Input-Encoding", import_ramda8.isNotNil, "was not found on module")).chain(checkTag("Output-Encoding", import_ramda8.isNotNil, "was not found on module")).bimap(
    logger.tap("Verifying module source failed: %s"),
    logger.tap("Verified module source")
  );
}
function verifySchedulerWith({ logger, validateScheduler }) {
  validateScheduler = fromPromise(validateSchedulerSchema.implement(validateScheduler));
  return (scheduler) => of(scheduler).chain(
    (scheduler2) => validateScheduler(scheduler2).chain((isValid) => isValid ? Resolved(scheduler2) : Rejected(`Valid Scheduler-Location owned by ${scheduler2} not found`))
  ).bimap(
    logger.tap("Verifying scheduler failed: %s"),
    logger.tap("Verified scheduler")
  );
}
function verifySignerWith({ logger }) {
  return (signer) => of(signer).map(logger.tap("Checking for signer")).chain((signer2) => signer2 ? Resolved(signer2) : Rejected("signer not found"));
}
function verifyInputsWith(env) {
  const logger = env.logger.child("verifyInput");
  env = { ...env, logger };
  const verifyModule = verifyModuleWith(env);
  const verifyScheduler = verifySchedulerWith(env);
  const verifySigner = verifySignerWith(env);
  return (ctx) => {
    return of(ctx).chain((ctx2) => verifyModule(ctx2.module).map(() => ctx2)).chain((ctx2) => verifyScheduler(ctx2.scheduler)).map(() => ctx).chain((ctx2) => verifySigner(ctx2.signer).map(() => ctx2)).bimap(
      logger.tap("Error when verify input: %s"),
      logger.tap("Successfully verified inputs")
    );
  };
}

// src/lib/spawn/upload-process.js
var import_zod6 = require("zod");
var import_ramda9 = require("ramda");
var tagSchema3 = import_zod6.z.array(import_zod6.z.object({
  name: import_zod6.z.string(),
  value: import_zod6.z.string()
}));
function buildTagsWith2() {
  return (ctx) => {
    return of(ctx).map((0, import_ramda9.prop)("tags")).map((0, import_ramda9.defaultTo)([])).map((0, import_ramda9.concat)(import_ramda9.__, [
      { name: "Data-Protocol", value: "ao" },
      { name: "Variant", value: "ao.TN.1" },
      { name: "Type", value: "Process" },
      { name: "Module", value: ctx.module },
      { name: "Scheduler", value: ctx.scheduler },
      { name: "SDK", value: "ao" }
    ])).map(tagSchema3.parse).map((0, import_ramda9.assoc)("tags", import_ramda9.__, ctx));
  };
}
function buildDataWith2({ logger }) {
  function removeTagsByName(name) {
    return (tags) => (0, import_ramda9.reject)((0, import_ramda9.propEq)(name, "name"), tags);
  }
  return (ctx) => {
    return of(ctx).chain((0, import_ramda9.ifElse)(
      (0, import_ramda9.always)(ctx.data),
      /**
       * data is provided as input, so do nothing
       */
      () => Resolved(ctx),
      /**
       * Just generate a random value for data
       */
      () => Resolved(Math.random().toString().slice(-4)).map((0, import_ramda9.assoc)("data", import_ramda9.__, ctx)).map(
        (ctx2) => (0, import_ramda9.pipe)(
          (0, import_ramda9.prop)("tags"),
          removeTagsByName("Content-Type"),
          (0, import_ramda9.append)({ name: "Content-Type", value: "text/plain" }),
          (0, import_ramda9.assoc)("tags", import_ramda9.__, ctx2)
        )(ctx2)
      ).map(logger.tap('added pseudo-random string as process "data"'))
    ));
  };
}
function uploadProcessWith(env) {
  const logger = env.logger.child("uploadProcess");
  env = { ...env, logger };
  const buildTags = buildTagsWith2(env);
  const buildData = buildDataWith2(env);
  const deployProcess = deployProcessSchema.implement(env.deployProcess);
  return (ctx) => {
    return of(ctx).chain(buildTags).chain(buildData).chain(fromPromise(
      ({ data, tags, signer }) => deployProcess({ data, tags, signer: signerSchema.implement(signer) })
    )).map((res) => (0, import_ramda9.assoc)("processId", res.processId, ctx));
  };
}

// src/lib/spawn/index.js
function spawnWith(env) {
  const verifyInputs = verifyInputsWith(env);
  const uploadProcess = uploadProcessWith(env);
  return ({ module: module2, scheduler, signer, tags, data }) => {
    return of({ module: module2, scheduler, signer, tags, data }).chain(verifyInputs).chain(uploadProcess).map((ctx) => ctx.processId).bimap(errFrom, import_ramda10.identity).toPromise();
  };
}

// src/index.common.js
var DEFAULT_GATEWAY_URL = "https://arweave.net";
var DEFAULT_MU_URL = "https://ao-mu-1.onrender.com";
var DEFAULT_CU_URL = "https://ao-cu-1.onrender.com";
function connect({
  GATEWAY_URL: GATEWAY_URL2 = DEFAULT_GATEWAY_URL,
  MU_URL: MU_URL2 = DEFAULT_MU_URL,
  CU_URL: CU_URL2 = DEFAULT_CU_URL
} = {}) {
  const logger = createLogger("@permaweb/ao-sdk");
  const { locate, validate } = (0, import_ao_scheduler_utils.connect)({ cacheSize: 100, GATEWAY_URL: GATEWAY_URL2 });
  const resultLogger = logger.child("result");
  const result2 = resultWith({
    loadResult: loadResultWith({ fetch, CU_URL: CU_URL2, logger: resultLogger }),
    logger: resultLogger
  });
  const messageLogger = logger.child("message");
  const message2 = messageWith({
    loadProcessMeta: loadProcessMetaWith({ fetch }),
    locateScheduler: locate,
    deployMessage: deployMessageWith({ fetch, MU_URL: MU_URL2, logger: messageLogger }),
    logger: messageLogger
  });
  const spawnLogger = logger.child("spawn");
  const spawn2 = spawnWith({
    loadTransactionMeta: loadTransactionMetaWith({ fetch, GATEWAY_URL: GATEWAY_URL2 }),
    validateScheduler: validate,
    deployProcess: deployProcessWith({ fetch, MU_URL: MU_URL2, logger: spawnLogger }),
    logger: spawnLogger
  });
  return { result: result2, message: message2, spawn: spawn2 };
}

// src/client/node/wallet.js
var wallet_exports = {};
__export(wallet_exports, {
  createDataItemSigner: () => createDataItemSigner
});
var import_warp_arbundles = __toESM(require("warp-arbundles"), 1);
var { createData, ArweaveSigner } = import_warp_arbundles.default;
function createDataItemSigner(wallet) {
  const signer = async ({ data, tags, target, anchor }) => {
    const signer2 = new ArweaveSigner(wallet);
    const dataItem = createData(data, signer2, { tags, target, anchor });
    return dataItem.sign(signer2).then(async () => ({
      id: await dataItem.id,
      raw: await dataItem.getRaw()
    }));
  };
  return signer;
}

// src/index.js
var GATEWAY_URL = process.env.GATEWAY_URL || void 0;
var MU_URL = process.env.MU_URL || void 0;
var CU_URL = process.env.CU_URL || void 0;
var { result, message, spawn } = connect({ GATEWAY_URL, MU_URL, CU_URL });
var createDataItemSigner2 = wallet_exports.createDataItemSigner;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  connect,
  createDataItemSigner,
  message,
  result,
  spawn
});
